// simpel=> \d device.data;

// 											 Table "device.data"
// 	Column    |            Type             | Collation | Nullable |                 Default

// --------------+-----------------------------+-----------+----------+------------------------------------------

// 	id           | bigint                      |           | not null | nextval('device.data2_id_seq'::regclass)
// 	unit_id      | bigint                      |           | not null |
// 	timestamp    | timestamp without time zone |           | not null | now()
// 	voltage      | double precision            |           | not null |
// 	current      | double precision            |           | not null |
// 	power        | double precision            |           | not null |
// 	energy       | double precision            |           | not null |
// 	frequency    | double precision            |           | not null |
// 	power_factor | double precision            |           | not null |

// Indexes:

// 	"data_tstamp_idx" btree ("timestamp" DESC)
// 	"data_unique_idx" UNIQUE, btree (id, "timestamp")

// Foreign-key constraints:

// 	"fk_unit" FOREIGN KEY (unit_id) REFERENCES device.unit(id) ON DELETE CASCADE

// Triggers:

// 		ts_insert_blocker BEFORE INSERT ON device.data FOR EACH ROW EXECUTE FUNCTION _timescaledb_functions.insert_blocker()

// 	  exp get years with pagination

// SELECT

// 	EXTRACT(YEAR FROM timestamp) AS year,
// 	MIN(timestamp) AS first_timestamp,
// 	MAX(timestamp) AS last_timestamp,
// 	COUNT(*) AS total_data

// FROM device.data
// GROUP BY year
// ORDER BY year DESC
// LIMIT 5 OFFSET 0;

// // total years
// SELECT COUNT(DISTINCT EXTRACT(YEAR FROM timestamp)) AS total_years
// FROM device.data;
// */
package process

import (
	"fmt"
	"monitoring_service/logger"
	"monitoring_service/utils"

	"github.com/jmoiron/sqlx"
)

type YearList struct {
	Year                 int     `db:"year" json:"year"`
	FirstRecordTimestamp string  `db:"first_record_timestamp" json:"first_record_timestamp"`
	LastRecordTimestamp  string  `db:"last_record_timestamp" json:"last_record_timestamp"`
	EnergyConsumedCount  float64 `db:"max_energy" json:"energy_consumed_count"`
	TotalData            int     `db:"total_data" json:"total_data"`
	DataInterval         float64 `db:"data_interval" json:"data_interval"`
	TotalSize            float64 `db:"total_size" json:"total_size_bytes"`

	Voltage     YearVoltageListSummary     `json:"voltage"`
	Current     YearCurrentListSummary     `json:"current"`
	Power       YearPowerListSummary       `json:"power"`
	Frequency   YearFrequencyListSummary   `json:"frequency"`
	PowerFactor YearPowerFactorListSummary `json:"power_factor"`
}

type YearVoltageListSummary struct {
	Avg float64 `json:"avg"`
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type YearCurrentListSummary struct {
	Avg float64 `json:"avg"`
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type YearPowerListSummary struct {
	Avg float64 `json:"avg"`
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type YearFrequencyListSummary struct {
	Avg float64 `json:"avg"`
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type YearPowerFactorListSummary struct {
	Avg float64 `json:"avg"`
	Min float64 `json:"min"`
	Max float64 `json:"max"`
}

type yearRaw struct {
	YearList

	AvgVoltage float64 `db:"avg_voltage"`
	MinVoltage float64 `db:"min_voltage"`
	MaxVoltage float64 `db:"max_voltage"`

	AvgCurrent float64 `db:"avg_current"`
	MinCurrent float64 `db:"min_current"`
	MaxCurrent float64 `db:"max_current"`

	AvgPower float64 `db:"avg_power"`
	MinPower float64 `db:"min_power"`
	MaxPower float64 `db:"max_power"`

	AvgFrequency float64 `db:"avg_frequency"`
	MinFrequency float64 `db:"min_frequency"`
	MaxFrequency float64 `db:"max_frequency"`

	AvgPowerFactor float64 `db:"avg_power_factor"`
	MinPowerFactor float64 `db:"min_power_factor"`
	MaxPowerFactor float64 `db:"max_power_factor"`
}

/*
exp case : data years available (2000- 2025)

*/

func Get_Report_Year_List(referenceId string, conn *sqlx.DB, userID int64, role string, param map[string]any) utils.ResultFormat {
	result := utils.ResultFormat{
		ErrorCode:    "000000",
		ErrorMessage: "",
		Payload:      make(map[string]any),
	}

	// Validasi parameter device_id
	deviceId, ok := param["device_id"].(float64)
	if !ok || deviceId <= 0 {
		logger.Error(referenceId, fmt.Sprintf("ERROR - GetReportYearList - Invalid device_id: %v", param["device_id"]))
		result.ErrorCode = "400001"
		result.ErrorMessage = "Invalid device ID"
		return result
	}

	var deviceIdInt int = int(deviceId)

	// Validasi parameter page_size
	pageSize, ok := param["page_size"].(float64)
	if !ok || pageSize <= 0 {
		logger.Error(referenceId, fmt.Sprintf("ERROR - GetReportYearList - Invalid page_size: %v", param["page_size"]))
		result.ErrorCode = "400002"
		result.ErrorMessage = "Invalid page size"
		return result
	}

	// Validasi parameter sort_type
	sortType, ok := param["sort_type"].(string)
	if !ok || (sortType != "asc" && sortType != "desc") {
		logger.Error(referenceId, fmt.Sprintf("ERROR - GetReportYearList - Invalid sort_type: %v", param["sort_type"]))
		result.ErrorCode = "400005"
		result.ErrorMessage = "Invalid sort type. Must be 'asc' or 'desc'"
		return result
	}

	// Handle start_year parameter
	startYearParam, exists := param["start_year"]
	var startYear int
	var direction string
	var comparisonOperator, orderClause string

	if !exists || startYearParam == nil {
		// Halaman pertama: ambil MIN atau MAX tahun tergantung sortType
		var yearValue int
		yearQuery := `
	SELECT EXTRACT(YEAR FROM %s(timestamp)) 
	FROM device.data 
	WHERE unit_id = $1`

		if sortType == "desc" {
			err := conn.Get(&yearValue, fmt.Sprintf(yearQuery, "MAX"), deviceId)
			if err != nil {
				logger.Error(referenceId, "ERROR - GetReportYearList - Max Year Query Failed: ", err.Error())
				result.ErrorCode = "500003"
				result.ErrorMessage = "Failed to get default start year"
				return result
			}
		} else {
			err := conn.Get(&yearValue, fmt.Sprintf(yearQuery, "MIN"), deviceId)
			if err != nil {
				logger.Error(referenceId, "ERROR - GetReportYearList - Min Year Query Failed: ", err.Error())
				result.ErrorCode = "500003"
				result.ErrorMessage = "Failed to get default start year"
				return result
			}
		}

		startYear = yearValue
		logger.Debug(referenceId, fmt.Sprintf("DEBUG - GetReportYearList - sort_type: %v, start year: %d", param["sort_type"], startYear))

		// Halaman pertama → tidak perlu operator pembanding
		orderClause = sortType
	} else {
		// Halaman selanjutnya → butuh arah dan operator pembanding
		startYear = startYearParam.(int)

		logger.Debug(referenceId, fmt.Sprintf("DEBUG - GetReportYearList - start_year parameter: %d", startYear))

		directionRaw, ok := param["direction"].(string)
		if !ok || (directionRaw != "next" && directionRaw != "prev") {
			direction = "next"
		} else {
			direction = directionRaw
		}

		comparisonOperator, orderClause = getPaginationOperators(direction, sortType)
	}

	// Build query
	dataQuery := ""
	if comparisonOperator != "" {
		dataQuery = buildYearListQuery(comparisonOperator, orderClause)
	} else {
		dataQuery = buildYearListQuery("", orderClause) // tidak ada operator pembanding di halaman pertama
	}

	// Eksekusi query utama
	var rawList []yearRaw

	var err error
	if comparisonOperator != "" {
		err = conn.Select(&rawList, dataQuery, deviceId, startYear, pageSize)
	} else {
		err = conn.Select(&rawList, dataQuery, deviceId, pageSize)
	}

	if err != nil {
		logger.Error(referenceId, "ERROR - GetReportYearList - Data Query Failed: ", err.Error())
		result.ErrorCode = "500002"
		result.ErrorMessage = "Failed to fetch year data"
		return result
	}

	// Transformasi data raw ke struktur response
	yearList := transformRawToYearList(rawList)

	// Hitung tahun sebelumnya dan berikutnya untuk pagination
	nextStartYear, prevStartYear := calculatePaginationYears(rawList, direction, sortType)

	// Verifikasi keberadaan tahun sebelumnya dan berikutnya di database
	nextStartYear, prevStartYear = verifyYearExistence(
		conn, referenceId, deviceIdInt,
		nextStartYear, prevStartYear,
		comparisonOperator, reverseComparisonOperator(comparisonOperator),
	)

	// Hitung total tahun yang tersedia
	totalYears, err := getTotalYears(conn, deviceIdInt)
	if err != nil {
		logger.Error(referenceId, "ERROR - GetReportYearList - Count Total Year Failed: ", err.Error())
	}

	// Siapkan response
	prepareResponse(result, yearList, nextStartYear, prevStartYear, totalYears)

	return result
}

// Fungsi helper untuk menentukan operator pagination
func getPaginationOperators(direction, sortType string) (string, string) {
	var comparisonOperator string
	if direction == "next" {
		if sortType == "desc" {
			comparisonOperator = "<"
		} else {
			comparisonOperator = ">"
		}
	} else {
		if sortType == "desc" {
			comparisonOperator = ">"
		} else {
			comparisonOperator = "<"
		}
	}
	return comparisonOperator, sortType
}

// Fungsi helper untuk membangun query
func buildYearListQuery(comparisonOperator, orderClause string) string {
	yearFilter := ""
	if comparisonOperator != "" {
		//yearFilter = fmt.Sprintf("AND ys.year %s $2", comparisonOperator)
		yearFilter = fmt.Sprintf("AND ys.year %s $2::int", comparisonOperator)

	}

	return fmt.Sprintf(`
	WITH monthly_energy AS (
		SELECT
			EXTRACT(YEAR FROM timestamp)::int AS year,
			EXTRACT(MONTH FROM timestamp)::int AS month,
			MAX(energy) AS max_energy
		FROM device.data
		WHERE unit_id = $1
		GROUP BY year, month
	),
	yearly_summary AS (
		SELECT
			EXTRACT(YEAR FROM d.timestamp)::int AS year,
			d.unit_id,
			TO_CHAR(MIN(d.timestamp), 'YYYY-MM-DD HH24:MI:SS') AS first_record_timestamp,
			TO_CHAR(MAX(d.timestamp), 'YYYY-MM-DD HH24:MI:SS') AS last_record_timestamp,
			COUNT(*)::int AS total_data,
			(EXTRACT(EPOCH FROM MAX(d.timestamp) - MIN(d.timestamp)) / NULLIF(COUNT(*) - 1, 0)) AS data_interval,
			SUM(pg_column_size(d.*))::float AS total_size,
			AVG(voltage) AS avg_voltage,
			MIN(voltage) AS min_voltage,
			MAX(voltage) AS max_voltage,
			AVG(current) AS avg_current,
			MIN(current) AS min_current,
			MAX(current) AS max_current,
			AVG(power) AS avg_power,
			MIN(power) AS min_power,
			MAX(power) AS max_power,
			AVG(frequency) AS avg_frequency,
			MIN(frequency) AS min_frequency,
			MAX(frequency) AS max_frequency,
			AVG(power_factor) AS avg_power_factor,
			MIN(power_factor) AS min_power_factor,
			MAX(power_factor) AS max_power_factor
	FROM device.data d
	WHERE unit_id = $1
	GROUP BY year, d.unit_id
	)
	SELECT
		ys.year,
		COALESCE(ys.first_record_timestamp, '') AS first_record_timestamp,
		COALESCE(ys.last_record_timestamp, '') AS last_record_timestamp,
		COALESCE(ys.total_data, 0) AS total_data,
		COALESCE(ys.total_size, 0) AS total_size,
		COALESCE(ys.data_interval, 0) AS data_interval,
		COALESCE(SUM(me.max_energy), 0) AS max_energy,
		COALESCE(ys.avg_voltage, 0) AS avg_voltage,
		COALESCE(ys.min_voltage, 0) AS min_voltage,
		COALESCE(ys.max_voltage, 0) AS max_voltage,
		COALESCE(ys.avg_current, 0) AS avg_current,
		COALESCE(ys.min_current, 0) AS min_current,
		COALESCE(ys.max_current, 0) AS max_current,
		COALESCE(ys.avg_power, 0) AS avg_power,
		COALESCE(ys.min_power, 0) AS min_power,
		COALESCE(ys.max_power, 0) AS max_power,
		COALESCE(ys.avg_frequency, 0) AS avg_frequency,
		COALESCE(ys.min_frequency, 0) AS min_frequency,
		COALESCE(ys.max_frequency, 0) AS max_frequency,
		COALESCE(ys.avg_power_factor, 0) AS avg_power_factor,
		COALESCE(ys.min_power_factor, 0) AS min_power_factor,
		COALESCE(ys.max_power_factor, 0) AS max_power_factor
	FROM yearly_summary ys
	LEFT JOIN monthly_energy me ON ys.year = me.year
	WHERE ys.unit_id = $1
	%s
	GROUP BY
		ys.year,
		ys.first_record_timestamp,
		ys.last_record_timestamp,
		ys.total_data,
		ys.total_size,
		ys.data_interval,
		ys.avg_voltage, ys.min_voltage, ys.max_voltage,
		ys.avg_current, ys.min_current, ys.max_current,
		ys.avg_power, ys.min_power, ys.max_power,
		ys.avg_frequency, ys.min_frequency, ys.max_frequency,
		ys.avg_power_factor, ys.min_power_factor, ys.max_power_factor
	ORDER BY ys.year %s
	LIMIT $3`, yearFilter, orderClause)
}

// Fungsi helper untuk transform data raw ke struktur response
func transformRawToYearList(rawList []yearRaw) []YearList {
	var yearList []YearList
	for _, raw := range rawList {
		raw.Voltage = YearVoltageListSummary{
			Avg: raw.AvgVoltage,
			Min: raw.MinVoltage,
			Max: raw.MaxVoltage,
		}
		raw.Current = YearCurrentListSummary{
			Avg: raw.AvgCurrent,
			Min: raw.MinCurrent,
			Max: raw.MaxCurrent,
		}
		raw.Power = YearPowerListSummary{
			Avg: raw.AvgPower,
			Min: raw.MinPower,
			Max: raw.MaxPower,
		}
		raw.Frequency = YearFrequencyListSummary{
			Avg: raw.AvgFrequency,
			Min: raw.MinFrequency,
			Max: raw.MaxFrequency,
		}
		raw.PowerFactor = YearPowerFactorListSummary{
			Avg: raw.AvgPowerFactor,
			Min: raw.MinPowerFactor,
			Max: raw.MaxPowerFactor,
		}
		yearList = append(yearList, raw.YearList)
	}
	return yearList
}

// Fungsi helper untuk menghitung tahun pagination
func calculatePaginationYears(rawList []yearRaw, direction, sortType string) (nextStartYear, prevStartYear any) {
	if len(rawList) == 0 {
		return nil, nil
	}

	firstYear := rawList[0].Year
	lastYear := rawList[len(rawList)-1].Year

	// Penyesuaian arah navigasi
	if sortType == "desc" {
		if direction == "next" {
			nextStartYear = lastYear - 1
			prevStartYear = firstYear + 1
		} else {
			nextStartYear = firstYear + 1
			prevStartYear = lastYear - 1
		}
	} else {
		if direction == "next" {
			nextStartYear = lastYear + 1
			prevStartYear = firstYear - 1
		} else {
			nextStartYear = firstYear - 1
			prevStartYear = lastYear + 1
		}
	}

	return nextStartYear, prevStartYear
}

// Fungsi helper untuk membalik operator perbandingan
func reverseComparisonOperator(op string) string {
	switch op {
	case "<":
		return ">"
	case ">":
		return "<"
	case "<=":
		return ">="
	case ">=":
		return "<="
	default:
		return op
	}
}

func verifyYearExistence(conn *sqlx.DB, referenceId string, deviceId int, nextStartYear, prevStartYear any, comparisonOp, reverseOp string) (any, any) {
	// Get the earliest and latest years available in the database
	var earliestYear, latestYear int
	err := conn.QueryRow(`
		SELECT 
			MIN(EXTRACT(YEAR FROM timestamp)::int as min_year,
			MAX(EXTRACT(YEAR FROM timestamp)::int as max_year
		FROM device.data
		WHERE unit_id = $1
	`, deviceId).Scan(&earliestYear, &latestYear)

	if err != nil {
		logger.Error(referenceId, "ERROR - verifyYearExistence - Failed to get min/max years: ", err.Error())
		return nil, nil
	}

	// Check if nextStartYear exists in the database
	if nextStartYear != nil {
		nextYear, ok := nextStartYear.(int)
		if !ok {
			// Try to convert from other numeric types if needed
			if nextFloat, ok := nextStartYear.(float64); ok {
				nextYear = int(nextFloat)
			} else {
				nextStartYear = nil
				return nextStartYear, prevStartYear
			}
		}

		// If we're trying to go beyond the earliest/latest year boundary, set to null
		if (comparisonOp == "<" && nextYear <= earliestYear) ||
			(comparisonOp == ">" && nextYear >= latestYear) {
			nextStartYear = nil
		} else {
			// Double check that this year actually has data
			var hasNextYear bool
			err := conn.Get(&hasNextYear, `
				SELECT EXISTS (
					SELECT 1
					FROM device.data
					WHERE unit_id = $1
					AND EXTRACT(YEAR FROM timestamp)::int `+comparisonOp+` $2
				)`, deviceId, nextYear)

			if err != nil {
				logger.Error(referenceId, "ERROR - verifyYearExistence - Check next year existence failed: ", err.Error())
				nextStartYear = nil
			} else if !hasNextYear {
				nextStartYear = nil
			}
		}
	}

	// Check if prevStartYear exists in the database
	if prevStartYear != nil {
		prevYear, ok := prevStartYear.(int)
		if !ok {
			// Try to convert from other numeric types if needed
			if prevFloat, ok := prevStartYear.(float64); ok {
				prevYear = int(prevFloat)
			} else {
				prevStartYear = nil
				return nextStartYear, prevStartYear
			}
		}

		// If we're trying to go beyond the earliest/latest year boundary, set to null
		if (reverseOp == "<" && prevYear <= earliestYear) ||
			(reverseOp == ">" && prevYear >= latestYear) {
			prevStartYear = nil
		} else {
			// Double check that this year actually has data
			var hasPrevYear bool
			err := conn.Get(&hasPrevYear, `
				SELECT EXISTS (
					SELECT 1
					FROM device.data
					WHERE unit_id = $1
					AND EXTRACT(YEAR FROM timestamp)::int `+reverseOp+` $2
				)`, deviceId, prevYear)

			if err != nil {
				logger.Error(referenceId, "ERROR - verifyYearExistence - Check prev year existence failed: ", err.Error())
				prevStartYear = nil
			} else if !hasPrevYear {
				prevStartYear = nil
			}
		}
	}

	return nextStartYear, prevStartYear
}

// Fungsi helper untuk mendapatkan total tahun
func getTotalYears(conn *sqlx.DB, deviceId int) (int, error) {
	var totalYears int
	err := conn.Get(&totalYears, `
		SELECT COUNT(DISTINCT EXTRACT(YEAR FROM timestamp)::int
		FROM device.data
		WHERE unit_id = $1`, deviceId)
	return totalYears, err
}

// Fungsi helper untuk menyiapkan response
func prepareResponse(result utils.ResultFormat, yearList []YearList, nextStartYear, prevStartYear any, totalYears int) {
	result.Payload["year_list"] = yearList
	result.Payload["next_start_year"] = nextStartYear
	result.Payload["prev_start_year"] = prevStartYear
	result.Payload["total_data"] = totalYears
}
